#!/usr/bin/python3
import argparse
import configparser
import enum
import logging
import os
import random
import re
import requests
import selectors
import socket
import string
import threading
import time
import types

# Server name (config)
SERVER = 'localhost'
# Version
VERSION = '0.1.0'
# Startup timestamp
STARTED = time.strftime('%a %b %d %Y at %H:%M:%S UTC', time.gmtime())
# Refresh in seconds for periodic (config)
REFRESH = 3
# IRC messages are pretty short and should fit with all the commands (config)
BUFFER = 1024
# Use UTF-8 for all network communication (config)
ENCODING = 'utf-8'
# FIXME: Get from settings per channel (dynamic)
COLOR = '#424242'

# Should be configurable
ENDPOINT = 'https://alik.contyk.dev/api'

logging.basicConfig(format='%(scatime)s : %(levelname)s : %(message)s', level=logging.INFO)

logger = logging.getLogger(__name__)
sel = selectors.DefaultSelector()

class IRC(enum.Enum):
    """Provides IRC response code mappings.

    An enum class, it holds response codes for each defined IRC
    keyword response.  Helps with readability.  Only the actual
    codes are sent, however.

    Based on RFC 2812.
    """
    RPL_WELCOME = '001'
    RPL_YOURHOST = '002'
    RPL_CREATED = '003'
    RPL_MYINFO = '004'
    RPL_BOUNCE = '005'
    RPL_TRACELINK = '200'
    RPL_TRACECONNECTING = '201'
    RPL_TRACEHANDSHAKE = '202'
    RPL_TRACEUNKNOWN = '203'
    RPL_TRACEOPERATOR = '204'
    RPL_TRACEUSER = '205'
    RPL_TRACESERVER = '206'
    RPL_TRACESERVICE = '207'
    RPL_TRACENEWTYPE = '208'
    RPL_TRACECLASS = '209'
    RPL_TRACERECONNECT = '210'
    RPL_STATSLINKINFO = '211'
    RPL_STATSCOMMANDS = '212'
    RPL_ENDOFSTATS = '219'
    RPL_STATSUPTIME = '242'
    RPL_STATSONLINE = '243'
    RPL_UMODEIS = '221'
    RPL_SERVLIST = '234'
    RPL_SERVLISTEND = '235'
    RPL_LUSERCLIENT = '251'
    RPL_LUSEROP = '252'
    RPL_LUSERUNKNOWN = '253'
    RPL_LUSERCHANNELS = '254'
    RPL_LUSERME = '255'
    RPL_ADMINME = '236'
    RPL_ADMINLOC1 = '257'
    RPL_ADMINLOC2 = '258'
    RPL_ADMINEMAIL = '259'
    RPL_TRACELOG = '261'
    RPL_TRACEEND = '262'
    RPL_TRYAGAIN = '263'
    RPL_AWAY = '301'
    RPL_USERHOST = '302'
    RPL_ISON = '303'
    RPL_UNAWAY = '305'
    RPL_NOWAWAY = '306'
    RPL_WHOISUSER = '311'
    RPL_WHOISSERVER = '312'
    RPL_WHOISOPERATOR = '313'
    RPL_WHOWASUSER = '314'
    RPL_ENDOFWHO = '315'
    RPL_WHOISIDLE = '317'
    RPL_ENDOFWHOIS = '318'
    RPL_WHOISCHANNELS = '319'
    RPL_LISTSTART = '321'
    RPL_LIST = '322'
    RPL_LISTEND = '323'
    RPL_CHANNELMODEIS = '324'
    RPL_UNIQOPIS = '325'
    RPL_NOTOPIC = '331'
    RPL_TOPIC = '332'
    RPL_INVITING = '341'
    RPL_SUMMONING = '342'
    RPL_INVITELIST = '346'
    RPL_ENDOFINVITELIST = '347'
    RPL_EXCEPTLIST = '348'
    RPL_ENDOFEXCEPTLIST = '349'
    RPL_VERSION = '351'
    RPL_WHOREPLY = '352'
    RPL_NAMEREPLY = '353'
    RPL_LINKS = '364'
    RPL_ENDOFLINKS = '365'
    RPL_ENDOFNAMES = '366'
    RPL_BANLIST = '367'
    RPL_ENDOFBANLIST = '368'
    RPL_ENDOFWHOWAS = '369'
    RPL_INFO = '371'
    RPL_MOTD = '372'
    RPL_ENDOFINFO = '374'
    RPL_MOTDSTART = '375'
    RPL_ENDOFMOTD = '376'
    RPL_YOUREOPER = '381'
    RPL_REHASHING = '382'
    RPL_YOURESERVICE = '383'
    RPL_TIME = '391'
    RPL_USERSSTART = '392'
    RPL_USERS = '393'
    RPL_ENDOFUSERS = '394'
    RPL_NOUSERS = '395'
    ERR_NOSUCHNICK = '401'
    ERR_NOSUCHSERVER = '402'
    ERR_NOSUCHCHANNEL = '403'
    ERR_CANNOTSENDTOCHAN = '404'
    ERR_TOOMANYCHANNELS = '405'
    ERR_WASNOSUCHNICK = '406'
    ERR_TOOMANYTARGETS = '407'
    ERR_NOSUCHSERVICE = '408'
    ERR_NOORIGIN = '409'
    ERR_NORECIPIENT = '411'
    ERR_NOTEXTTOSEND = '412'
    ERR_NOTOPLEVEL = '413'
    ERR_WILDTOPLEVEL = '414'
    ERR_BADMASK = '415'
    ERR_UNKNOWNCOMMAND = '421'
    ERR_NOMOTD = '422'
    ERR_NOADMININFO = '423'
    ERR_FILEERROR = '424'
    ERR_NONICKNAMEGIVEN = '431'
    ERR_ERRONEUSNICKNAME = '432'
    ERR_NICKNAMEINUSE = '433'
    ERR_NICKCOLLISION = '436'
    ERR_UNAVAILRESOURCE = '437'
    ERR_USERNOTINCHANNEL = '441'
    ERR_NOTONCHANNEL = '442'
    ERR_USERONCHANNEL = '443'
    ERR_NOLOGIN = '444'
    ERR_SUMMONDISABLED = '445'
    ERR_USERSDISABLED = '446'
    ERR_NOTREGISTERED = '451'
    ERR_NEEDMOREPARAMS = '461'
    ERR_ALREADYREGISTERED = '462'
    ERR_NOPERMFORHOST = '463'
    ERR_PASSWDMISMATCH = '464'
    ERR_YOUREBANNEDCREEP = '465'
    ERR_YOUWILLBEBANNED = '466'
    ERR_KEYSET = '467'
    ERR_CHANNELISFULL = '471'
    ERR_UNKNOWNMODE = '472'
    ERR_INVITEONLYCHAN = '473'
    ERR_BANNEDFROMCHAN = '474'
    ERR_BADCHANNELKEY = '475'
    ERR_BADCHANMASK = '476'
    ERR_NOCHANMODES = '477'
    ERR_BANLISTFULL = '478'
    ERR_NOPRIVILEGES = '481'
    ERR_CHANOPRIVSNEEDED = '482'
    ERR_CANTKILLSERVER = '483'
    ERR_RESTRICTED = '484'
    ERR_UNIQOPPRIVSNEEDED = '485'
    ERR_NOOPERHOST = '491'
    ERR_UMODEUNKNOWNFLAG = '501'
    ERR_USERSDONTMATCH = '502'

class Client:
    """Provides an abstraction of the connection session.

    Instances represent each individual connection, hold its client socket,
    Malíček session, and various collected metadata.
    """
    def __init__(self, sock):
        """Class constructor.

        Initializes instance variables; these include the socket reference,
        the endpoint, the Malíček session reference, the user nickname, their
        password, the channels they've joined, information about other nicks
        they've collected, the automatic periodic thread reference, and thread
        locks for shared resources.

        Requires the socket reference.

        The default nickname is '*', as per RFC 2812.

        :param sock: The socket reference of this connection
        :returns: A Client instance
        """
        self.socket = sock
        self.endpoint = None
        self.session = None
        self.user = '*'
        self.password = None
        self.userstring = None
        # Dict of channels we're in
        # Values are another dict, with `seen` and `activity` as keys
        self.channels = dict()
        # All users we know about, userful for user IDs in JOIN & PART,
        # and potentially also for WHO, WHOIS, NAMES and ISON
        self.nicks = dict()
        # Our auto thread for fetching messages and other updates
        self.auto = threading.Thread(target=self.periodic, daemon=True)
        # Locks for commonly accessed shared resources
        self.lock = {
            x: threading.Lock() for x in (
                'channels',
                'nicks',
            )
        }

    def __del__(self):
        """Destroys the session instance.

        Attempts to log off, properly destroys the session and clears the
        Client.periodic() thread.  Called automatically by GC.
        """
        if self.registered():
            self.logout()
            self.session = None
            self.auto.join()

    def setup(self):
        """Creates an instance of the session.

        Automatically logs in and maintains the session cookie.  Clears the
        session upon failure not to confuse Client.registered().

        :returns: True on success, False otherwise
        """
        self.session = requests.Session()
        self.endpoint = ENDPOINT
        if self.endpoint.endswith('/'):
            self.endpoint = self.endpoint[0:-1]
        if self.login():
            self.auto.start()
            return True
        self.session = None
        return False

    # TODO: Check if the message begins with an originator
    #       and if so, strip it.
    def handle(self, msg):
        """Consume messages from the socket.

        The class entry point.  Messages extracted from the socket stream
        are passed to this method as a byte sequence.

        Decodes the input, splits it into commands and arguments, and directs
        the data to respective handlers.

        Provides very basic checking for sanity.

        :param msg: Byte sequence representing message input
        """
        msg = msg.decode(ENCODING)
        logger.debug('Handling input: {}'.format(msg))
        pos = msg.find(' ')
        if pos == -1:
            cmd = msg
            args = None
        else:
            cmd = msg[0:pos]
            args = msg[pos + 1:]
        if not cmd:
            return
        if not args and cmd in ('NICK', 'USER', 'PASS', 'PART', 'TOPIC',
                'NAMES', 'PRIVMSG', 'NOTICE'):
            logger.debug('Received {} with not enough parameters.'.format(cmd))
            self.error(IRC.ERR_NEEDMOREPARAMS)
            return
        if self.registered() and cmd in ('NICK', 'USER', 'PASS'):
            self.error(IRC.ERR_ALREADYREGISTERED)
            return
        elif not self.registered() and cmd not in ('NICK', 'USER', 'PASS'):
            self.error(IRC.ERR_NOTREGISTERED)
            return
        if cmd == 'PASS':
            self.handle_pass(args)
        elif cmd == 'USER':
            self.handle_user(args)
        elif cmd == 'NICK':
            self.handle_nick(args)
        elif cmd == 'OPER':
            self.handle_oper(args)
        elif cmd == 'MODE':
            self.handle_mode(args)
        elif cmd == 'SERVICE':
            self.handle_service(args)
        elif cmd == 'QUIT':
            self.handle_quit(args)
        elif cmd == 'SQUIT':
            self.handle_squit(args)
        elif cmd == 'JOIN':
            self.handle_join(args)
        elif cmd == 'PART':
            self.handle_part(args)
        elif cmd == 'TOPIC':
            self.handle_topic(args)
        elif cmd == 'NAMES':
            self.handle_names(args)
        elif cmd == 'LIST':
            self.handle_list(args)
        elif cmd == 'INVITE':
            self.handle_invite(args)
        elif cmd == 'KICK':
            self.handle_kick(args)
        elif cmd == 'PRIVMSG':
            self.handle_privmsg(args)
        elif cmd == 'NOTICE':
            self.handle_notice(args)
        elif cmd == 'MOTD':
            self.handle_motd(args)
        elif cmd == 'LUSERS':
            self.handle_lusers(args)
        elif cmd == 'VERSION':
            self.handle_version(args)
        elif cmd == 'STATS':
            self.handle_stats(args)
        elif cmd == 'LINKS':
            self.handle_link(args)
        elif cmd == 'TIME':
            cmd.handle_time(args)
        elif cmd == 'CONNECT':
            cmd.handle_connect(args)
        elif cmd == 'TRACE':
            cmd.handle_trace(args)
        elif cmd == 'ADMIN':
            self.handle_admin(args)
        elif cmd == 'INFO':
            self.handle_info(args)
        elif cmd == 'SERVLIST':
            self.handle_servlist(args)
        elif cmd == 'SQUERY':
            self.handle_squery(args)
        elif cmd == 'WHO':
            self.handle_who(args)
        elif cmd == 'WHOIS':
            self.handle_whois(args)
        elif cmd == 'WHOWAS':
            self.handle_whowas(args)
        elif cmd == 'KILL':
            self.handle_kill(args)
        elif cmd == 'PING':
            self.handle_ping(args)
        elif cmd == 'PONG':
            self.handle_pong(args)
        elif cmd == 'ERROR':
            self.handle_error(args)
        elif cmd == 'AWAY':
            self.handle_away(args)
        elif cmd == 'REHASH':
            self.handle_rehash(args)
        elif cmd == 'DIE':
            self.handle_die(args)
        elif cmd == 'RESTART':
            self.handle_restart(args)
        elif cmd == 'SUMMON':
            self.handle_summon(args)
        elif cmd == 'USERS':
            self.handle_users(args)
        elif cmd == 'WALLOPS':
            self.handle_wallops(args)
        elif cmd == 'USERHOST':
            self.handle_userhost(args)
        elif cmd == 'ISON':
            self.handle_ison(args)
        else:
            self.error(IRC.ERR_UNKNOWNCOMMAND)
            logger.warning('Unknown command: {}'.format(cmd))
            logger.warning('Unknown arguments: {}'.format(args))
            return

    def reply(self, msg):
        """Send a standard reply in response to a command.

        Only so slightly simplifies sending code responses back to the client.
        The method only prefixes each message with the server name.

        Unfortunately, as each message has a different format, this is the
        best we can currently offer.

        The message must include everything to be sent: the code, the possible
        arguments, additional human readable messages and more.

        :param msg: The message to send
        """
        logger.debug('Responding with {}'.format(msg))
        self.socket.sendall(
            ':{} '.format(SERVER).encode(ENCODING) + \
            msg.encode(ENCODING) + \
            b'\r\n'
        )

    def error(self, err, response=None):
        """Send an error reply in response to a command.

        Simplifies error responses.  The response message is optional and
        standard messages for the given error codes are used, if known.

        If not, the default error message is the error code constant.

        This is nott he same as the ERROR command.  For that one, refer
        to Client.do_error().

        :param err: The error code, an enum of the IRC class
        :param response: Optional error message
        """
        logger.debug('Responding with error: {}'.format(err))
        if err == IRC.ERR_NEEDMOREPARAMS:
            response = response or 'Not enough parameters given.'
        elif err == IRC.ERR_UNKNOWNCOMMAND:
            response = response or 'Command not implemented.'
        elif err == IRC.ERR_PASSWDMISMATCH:
            response = response or 'Authentication failed, sorry.'
        elif err == IRC.ERR_ALREADYREGISTERED:
            response = response or 'You are already logged in.'
        elif err == IRC.ERR_NOTREGISTERED:
            response = response or 'You must log in to continue.'
        elif err == IRC.ERR_NOSUCHNICK:
            respose = respose or 'Private messaging is unsupported.'
        elif err == IRC.ERR_NOTEXTTOSEND:
            response = response or 'No message specified.'
        elif err == IRC.ERR_CANNOTSENDTOCHAN:
            response = response or 'You must join the channel first.'
        response = response or err
        self.reply('{} {} :{}'.format(
            err.value,
            self.user,
            response,
        ))

    # TODO: Handle room errors
    # TODO: Handle OPER MODEs
    def periodic(self):
        """Automatic periodic check of active channels.

        Periodically checks all channels the user has joined, querying for
        new messages, users joining or parting, mode changes and more.

        Triggers relevant IRC actions to simulate the activity.  Maintains
        presence via keepalive calls, whenever required.

        The backbone of mlck.  Runs in an idependent thread.

        Note this holds the global channels lock.
        """
        while self.registered():
            self.lock['channels'].acquire()
            for chan in self.channels.keys():
                logger.debug('Running a periodic refresh for {}.'.format(chan))
                res = self.get('rooms/{}'.format(chan[1:]))
                messages = list()
                for msg in res.json()['messages']:
                    if chan not in self.channels:
                        return
                    if msg == self.channels[chan]['seen']:
                        break
                    messages.append(msg)
                messages.reverse()
                if messages:
                    self.channels[chan]['seen'] = messages[-1]
                if int(time.time()) - self.channels[chan]['activity'] > 15 * 60:
                    self.channels[chan]['activity'] = int(time.time())
                    self.keepalive(chan)
                for usr in res.json()['users']:
                    self.info(
                        usr['name'],
                        uid=usr['id'],
                        link=usr['link'],
                        sex=usr['sex'],
                        age=usr['age'],
                        oper=True if usr['admin'] else False,
                    )
                for msg in messages:
                    if msg['nick'] == self.user:
                        continue
                    if msg['type'] == 'system':
                        if msg['event']['type'] == 'join':
                            self.do_join(
                                msg['event']['source'],
                                chan,
                            )
                            continue
                        if msg['event']['type'] == 'part' or msg['event']['type'] == 'kick':
                            self.do_part(
                                msg['event']['source'] if msg['event']['source'] else msg['event']['target'],
                                chan,
                                msg['message'],
                            )
                            continue
                    self.do_privmsg(
                        msg['nick'] if msg['nick'] else '*',
                        chan,
                        emoji(msg['message']) if not msg['private'] else '\x02[{}, pst!] {}\x0f'.format(', '.join(msg['private']), emoji(msg['message']))
                    )
            self.lock['channels'].release()
            time.sleep(REFRESH)

    def keepalive(self, chan):
        """Send a keepalive message.

        Generates a simple, hopefully unique keepalive message and sends it
        as a broken private message to the channel of choice.

        Prevents idling out even when inactive.

        The message takes form of "[ malíček/keepalive <16 bytes of hex> ]".

        :param chan: Channel name
        """
        msg = '[ malíček/keepalive {} ]'.format(
            ''.join(random.choice(string.hexdigits) for i in range(16))
        )
        self.post(
            'rooms/{}'.format(chan[1:]),
            {
                'action': 'post',
                'to': -1,
                'message': msg,
                'color': COLOR,
            }
        )

    def info(self, nick, uid=None, link=None, sex=None, age=None, oper=None):
        """Handle user information records

        Fetch and, optionally, store user details.  Different handles provide
        different details we may want to gather over time.

        Returns a dictionary of all the data configured for a given nicknames
        so far.  Keys include uid (the numerical system ID), link (the string
        form of the ID, sanitized nickname), sex, age and oper (True if the
        user is a moderator).

        :param nick: Nickname to query or update
        :param uid: Optional, save the numerical uid
        :param link: Optional, save the string id
        :param sex: Optional, save the sex
        :param age: Optional, save age
        :param oper: Optional, save the operator status
        :returns: A dictionary of all stored values
        """
        with self.lock['nicks']:
            if nick not in self.nicks:
                self.nicks[nick] = {
                    x: None for x in ('uid', 'link', 'sex', 'age', 'oper')
                }
            if uid:
                self.nicks[nick]['uid'] = uid
            if link:
                self.nicks[nick]['link'] = link
            if sex:
                self.nicks[nick]['sex'] = sex
            if age:
                self.nicks[nick]['age'] = age
            if oper:
                self.nicks[nick]['oper'] = oper
            return self.nicks[nick]

    def register(self):
        """Register a connection.

        Attempt to register the connection if all required data has been
        provided.  Called from handle_nick() and handle_user().
        """
        if self.user == '*' or not self.password or not self.userstring:
            return
        if self.setup():
            self.reply('{} {} :Welcome to Malíček.'.format(
                IRC.RPL_WELCOME.value,
                self.user,
                SERVER,
                self.user,
            ))
            self.reply('{} {} :Your host is {}, running version mlck-{}.'.format(
                IRC.RPL_YOURHOST.value,
                self.user,
                SERVER,
                VERSION,
            ))
            self.reply('{} {} :This server was created on {}'.format(
                IRC.RPL_CREATED.value,
                self.user,
                STARTED,
            ))
            # TODO: Advertise modes once we support them
            self.reply('{} {} :{} mlck-{}'.format(
                IRC.RPL_MYINFO.value,
                self.user,
                SERVER,
                VERSION,
            ))
        else:
            self.error(IRC.ERR_PASSWDMISMATCH)
            sel.unregister(self.socket)
            self.socket.close()

    def registered(self):
        """Check if our connection has been registered.

        Most of our functionality depends on having a registered session.
        This method checks whether we have one.

        :returns: True if we have a working session, False otherwise
        """
        if self.session:
            return True
        return False

    # TODO: Needs a timeout
    def get(self, handle):
        """Fetch Malíček handles using GET.

        A simple wrapper for fetching backend handles.  Returns raw request
        response objects.  Callers may check the status code or extract the data
        using the json() method.

        :param handle: API handle, appended to "ENDPOINT/"
        :returns: Request response object
        """
        return self.session.get(
            '{}/{}'.format(self.endpoint, handle)
        )

    # TODO: Needs a timeout
    def post(self, handle, data=None):
        """Fetch Malíček handles using POST

        A simple wrapper for fetching backend handles.  Returns raw request
        response objects.  Callers may check the status code or extract the data
        using the json() method.

        Optionally, a data structure can be passed representing the data to
        send.

        :param handle: API handle, appended to "ENDPOINT/"
        :param data: Data to send, if any
        :returns: Request response object
        """
        return self.session.post(
            '{}/{}'.format(self.endpoint, handle),
            json=data,
        )

    def login(self):
        """Initiate the Malíček session.

        Calls the /login resource, creating the session.  Having one is
        generally required for almost everything else.  Only works after
        PASS and NICK.  Should be called after USER.

        Clears the password from memory.

        :returns: True if we managed to log in, False otherwise
        """
        logger.debug('Logging in.')
        r = self.post(
            'login',
            {
                'user': self.user,
                'pass': self.password
            }
        ).status_code
        self.password = None
        return True if r == 200 else False

    def logout(self):
        """Terminate the Malíček session.

        Calls the /logout resource.  The only real use is a cleanup, so
        this gets called from the destructor.
        """
        logger.debug('Logging out.')
        self.get('logout')

    def rooms(self):
        """Fetch the /rooms resource.

        This is a shorthand for fetching the list of rooms.

        :returns: Request response
        """
        logger.debug('Fetching rooms.')
        return self.get('rooms').json()

    def do_privmsg(self, sender, target, message):
        """Send the PRIVMSG command.

        Sends a PRIVMSG message on behalf of the sender.

        The sender is the sender's nickname, which is translated into a
        virtual username formed from the link ID + @alik.cz.  If the link
        ID is unavailable, *@alik.cz is used instead.

        In the rare event of sending PART of behalf of *, don't do any
        user mangling.

        :param sender: The messaging person, their NICK
        :param target: The target, typically a channel
        :param message: The message to send
        """
        logger.debug('do_privmsg: {}, {}, {}'.format(sender, target, message))
        if sender != '*':
            sender = '{}!{}@alik.cz'.format(sender, self.info(sender)['link'] or '*')
        self.socket.sendall(':{} PRIVMSG {} :{}'.format(
                sender,
                target,
                message,
            ).encode(ENCODING) + \
            b'\r\n'
        )

    def do_notice(self, sender, target, message):
        """Send the NOTICE command.

        Sends a NOTICE message on behalf of the sender.

        The sender is the sender's nickname, which is translated into a
        virtual username formed from the link ID + @alik.cz.  If the link
        ID is unavailable, *@alik.cz is used instead.

        In the rare event of sending PART of behalf of *, don't do any
        user mangling.

        :param sender: The messaging person, their NICK
        :param target: The target, typically a channel
        :param message: The message to send
        """
        logger.debug('do_notice: {}, {}, {}'.format(sender, target, message))
        if sender != '*':
            sender = '{}!{}@alik.cz'.format(sender, self.info(sender)['link'] or '*')
        self.socket.sendall(':{} NOTICE {} :{}'.format(
                sender,
                target,
                message,
            ).encode(ENCODING) + \
            b'\r\n'
        )

    def do_join(self, sender, channel):
        """Send the JOIN command.

        Sends JOIN to the channel on behalf of the sender.

        The sender is the sender's nickname, which is translated into a
        virtual username formed from the link ID + @alik.cz.  If the link
        ID is unavailable, *@alik.cz is used instead.

        In the rare event of sending PART of behalf of *, don't do any
        user mangling.

        :param sender: The joining person, their NICK
        :param channel: The channel they are joining
        """
        logger.debug('do_join: {}, {}'.format(sender, channel))
        if sender != '*':
            sender = '{}!{}@alik.cz'.format(sender, self.info(sender)['link'] or '*')
        self.socket.sendall(':{} JOIN {}'.format(
                sender,
                channel,
            ).encode(ENCODING) + \
            b'\r\n'
        )

    def do_part(self, sender, channel, msg=None):
        """Send the PART command.

        Sends PART to the channel on behalf of the sender, with an optional
        parting message.

        The sender is the sender's nickname, which is translated into a
        virtual username formed from the link ID + @alik.cz.  If the link
        ID is unavailable, *@alik.cz is used instead.

        In the rare event of sending PART of behalf of *, don't do any
        user mangling.

        :param sender: The leaving person, their NICK
        :param channel: The channel they are leaving
        :param msg: Optional parting message
        """
        logger.debug('do_part: {}, {}, {}'.format(sender, channel, msg))
        if sender != '*':
            sender = '{}!{}@alik.cz'.format(sender, self.info(sender)['link'] or '*')
        self.socket.sendall(':{} PART {} :{}'.format(
                sender,
                channel,
                msg if msg else '',
            ).encode(ENCODING) + \
            b'\r\n'
        )

    def do_error(self, message=None):
        """Send the ERROR command.

        These are emitted by the server under special circumstances and they
        always target our only user, self.user.

        Not to be used for ERR replies.  See Client.error() for those.

        If no message is specified, "An error is an error." is sent.

        :param message: The error message to send
        """
        logger.debug('do_error: {}'.format(message))
        message = message or 'An error is an error.'
        self.socket.sendall(':{} ERROR :{}'.format(
                SERVER,
                message,
            ).encode(ENCODING) + \
            b'\r\n',
        )

    def handle_pass(self, args):
        """Handle PASS commands.

        Required for registering a session with us.  This needs to preceed
        the USER command which itself finishes the registration.

        :param args: <password>
        """
        logger.debug('handle_pass: (args hidden)')
        self.password = args

    def handle_nick(self, args):
        """Handle NICK commands.

        Set the nickname and use it Alík's username.  It doesn't make
        sense to change it later as it's your immutable remote identifier.

        Attempts to register the connection.

        :param args: <nickname>
        """
        logger.debug('handle_nick: {}'.format(args))
        self.user = args
        self.register()

    def handle_user(self, args):
        """Handle USER commands.

        Finishes the registration.  We don't actually care about the
        arguments as all, so we ignore them all.  No one will see you.

        The arguments are effectively ignored but stored.

        Attempts to register the connection.

        :param args: <USER string>
        """
        logger.debug('handle_user: (no args)')
        self.userstring = args
        self.register()

    def handle_oper(self, args):
        pass

    def handle_mode(self, args):
        pass

    def handle_server(self, args):
        pass

    # TODO: Leave all channels once done debugging
    # TODO: Respond with ERROR, huh
    def handle_quit(self, args):
        """Handle QUIT commands.

        The client is quitting.  Part all the active channels, unregister
        our selector and close the socket, unless they've already done that.

        Except that we don't do part the channels yet.  It's too early in
        the development and it could hinder testing with unnecessary spam.
        """
        logger.debug('handle_quit: (no args)')
        sel.unregister(self.socket)
        try:
            self.socket.close()
        except:
            pass

    def handle_squit(self, args):
        pass

    # TODO: Backlog whispers
    def handle_join(self, args):
        """Handle JOIN commands.

        Attempts to join the specified channels.  Potential keys are
        of no use to us so they're ignored.  JOIN must be confirmed
        upon success.  The client should also receive the channel topic
        and the list of users, including self.  Additionaly, we also
        send all visible backlog messages as the '*' user.

        Joining "0" is an equivalent of parting all the currently joined
        channels.

        Joining with no arguments is non-standard but common.  We accept
        it and do nothing.

        :param args: [0|<channel>[,<channel>]* [<key>[,<key>]*]]
        """
        logger.debug('handle_join: {}'.format(args))
        if not args:
            return
        if args == '0':
            self.lock['channels'].acquire()
            for chan in channels:
                del self.channels[chan]
                self.post(
                    'rooms/{}'.format(chan[1:]),
                    { 'action': 'leave' }
                )
                self.do_part(self.user, chan)
            self.lock['channels'].release()
        for chan in args.split(' ')[0].split(','):
            res = self.get('rooms/{}'.format(chan[1:]))
            if res.status_code != 200:
                continue
            for usr in res.json()['users']:
                self.info(
                    usr['name'],
                    uid=usr['id'],
                    link=usr['link'],
                    sex=usr['sex'],
                    age=usr['age'],
                    oper=True if usr['admin'] else False,
                )
            self.do_join(self.user, chan)
            self.reply('{} {} {} :{}'.format(
                IRC.RPL_TOPIC.value,
                self.user,
                chan,
                '{}{}'.format(
                    res.json()['name'],
                    ' | {}'.format(res.json()['topic']) if res.json()['topic'] else '',
                ),
            ))
            self.reply('{} {} = {} :{}'.format(
                IRC.RPL_NAMEREPLY.value,
                self.user,
                chan,
                ' '.join(
                    '{}{}'.format(
                        ('@' if x['admin'] else ''),
                        x['name'],
                    ) for x in res.json()['users']
                )
            ))
            self.reply('{} {} {} :{}'.format(
                IRC.RPL_ENDOFNAMES.value,
                self.user,
                chan,
                'End of /NAMES list.',
            ))
            messages = res.json()['messages']
            messages.reverse()
            for msg in messages:
                self.do_privmsg(
                    '*',
                    chan,
                    '[{}] ({}) {}'.format(
                        msg['time'] if msg['time'] else '??:??:??',
                        msg['nick'] if msg['nick'] else '*',
                        emoji(msg['message']),
                    ),
                )
            self.lock['channels'].acquire()
            self.channels[chan] = {
                'activity': int(time.time()),
            }
            if messages:
                self.channels[chan]['seen'] = messages[-1]
            self.lock['channels'].release()

    def handle_part(self, args):
        """Handle PART commands.

        Leaves the selected list of channels.  We do not have to
        check their presence as the backend doesn't care, although
        we could potentially cut a few nonsensical requests.

        We don't have anywhere to send the parting message so we
        simply ignore it.

        :param args: <channel>[,<channel>]*[ :<message>]
        """
        logger.debug('handle_part: {}'.format(args))
        for chan in args.split(' ')[0].split(','):
            self.lock['channels'].acquire()
            del self.channels[chan]
            self.lock['channels'].release()
            self.post(
                'rooms/{}'.format(chan[1:]),
                { 'action': 'leave' },
            )
            self.do_part(self.user, chan)

    # TODO: Implement this
    def handle_topic(self, args):
        """Handle TOPIC commands.

        Not implemented.

        :param args: ...
        """
        logger.debug('handle_topic: (no args)')
        self.error(IRC.ERR_UNKNOWNCOMMAND)

    # TODO: Implement this
    def handle_names(self, args):
        logger.debug('handle_names: {}'.format(args))
        self.error(IRC.ERR_UNKNOWNCOMMAND)

    # TODO: Add topic to name (blocked by Malicek support)
    def handle_list(self, args):
        """Handle LIST commands.

        Queries existing channels.  Lists all channels without
        arguments, or limits the output to channels that match one
        of the provided channel names.  These may contain the '*'
        wildcard, which we translate to '.*' in a regex.

        The optional target argument is ignored.

        The output includes the number of users in that channel,
        as well as its actual name.

        Rooms the user cannot join are not listed as the have no
        known ID.

        :param args: [<channel>[,<channel>]* [<target>]]
        """
        logger.debug('handle_list: {}'.format(args))
        only = set()
        if args:
            for pattern in args.split(' ')[0].split(','):
                pattern = re.escape(pattern)
                pattern = pattern.replace('\\#', '#')
                pattern = pattern.replace('\\?', '.')
                pattern = pattern.replace('\\*', '.*')
                only.add(re.compile('^{}$'.format(pattern)))
        for room in self.rooms():
            show = True
            if only:
                show = False
                for pattern in only:
                     if pattern.match(room['id']):
                         show = True
                         break
            if room['id'] is None:
                show = False
            if not show:
                continue
            self.reply('{} {} #{} {} :{}'.format(
                IRC.RPL_LIST.value,
                self.user,
                room['id'],
                len(room['users']),
                room['name'],
            ))
        self.reply('{} {} :End of LIST'.format(
            IRC.RPL_LISTEND.value,
            self.user,
        ))

    def handle_invite(self, args):
        pass

    def handle_kick(self, args):
        pass

    # TODO: Handle whispering
    # TODO: Remember colors per room and use them
    def handle_privmsg(self, args):
        """Handle PRIVMSG commands.

        The standard IRC messaging method, sends commands to channels
        or users.  Due to Alík's limitations, private messages cannot
        work outside of channels.  Messaging users is therefore disabled.

        Sending messages to channels one hasn't joined is similarly
        impossible and returns an error.

        ACTION messages are converted to "*<text>*" and sent as regular
        messages instead.  SOH is stripped.

        :param args: <msgtarget> <text>
        """
        logger.debug('handle_privmsg: {}'.format(args))
        chan, msg = args.split(' ', 1)
        if not chan.startswith('#'):
            self.error(IRC.ERR_NOSUCHNICK)
            return
        if len(msg) < 2:
            self.error(IRC.ERR_NOTEXTTOSEND)
            return
        self.lock['channels'].acquire()
        if chan not in self.channels:
            self.error(IRC.ERR_CANNOTSENDTOCHAN)
            return
        msg = msg[1:]
        if msg.startswith('\x01') and msg.endswith('\x01'):
            msg = msg.replace('\x01ACTION ', '*')
            msg = msg.replace('\x01', '*')
        self.post(
            'rooms/{}'.format(chan[1:]),
            {
                'action': 'post',
                'to': 0,
                'message': msg,
                'color': COLOR,
            },
        )
        self.channels[chan]['activity'] = int(time.time())
        self.lock['channels'].release()

    def handle_notice(self, args):
        """Handle NOTICE commands.

        This just calls handle_privmsg() as they're virtually
        identical in our context.

        :param args: <msgtarget> <text>
        """
        logger.debug('handle_notice: {}'.format(args))
        self.handle_privmsg(args)

    def handle_motd(self, args):
        pass

    def handle_lusers(self, args):
        pass

    def handle_version(self, args):
        pass

    def handle_stats(self, args):
        pass

    def handle_stats(self, args):
        pass

    def handle_links(self, args):
        pass

    def handle_time(self, args):
        pass

    def handle_connect(self, args):
        pass

    def handle_trace(self, args):
        pass

    def handle_admin(self, args):
        pass

    def handle_info(self, args):
        pass

    def handle_servlist(self, args):
        pass

    def handle_squery(self, args):
        pass

    # TODO: Age requires a Malicek update
    def handle_who(self, args):
        """Handle WHO commands.

        RFC 2812 is rather vague and unclear on this topic, however, WHO
        commands require one or two arguments, the first of which is a mask,
        the other is optionally the letter 'o'.

        The mask can be both a user mask or a channel mask and may include
        wildcards.

        We support this, except that if the mask begins with a '#', channel
        is assumed, user otherwise.  To search for channels beginning with a
        wildcard, '#*foo' must be requested.

        If 'o' is requested, the list returns only operators.

        For channels, we query every matching channel.  For user queries we
        aggregate the results and return them for channel '*', omitting
        operator flags.  This seems to be the common practice.

        The "real name" part is replaced by user details for convenience.

        User mask doesn't match against our virtual hostnames or servers,
        only IDs, nicknames and details.

        Channel queries omit channels the user cannot join as they have
        no visible room IDs.

        :param args: [<mask> [o]]
        """
        logger.debug('handle_who: {}'.format(args))
        args = args or ''
        rooms = self.rooms()
        args = args.split(' ')
        if args[0] in ('', '0'):
            args[0] = '*'
        mask = re.escape(args[0])
        mask = mask.replace('\\#', '#')
        mask = mask.replace('\\?', '.')
        mask = mask.replace('\\*', '.*')
        mask = re.compile('^{}$'.format(mask))
        if args[0].startswith('#'):
            for room in rooms:
                if not room['id']:
                    continue
                if not mask.match('#{}'.format(room['id'])):
                    continue
                for nick in room['users']:
                    if len(args) > 1 and args[1] == 'o' and not nick['admin']:
                        continue
                    self.reply('{} {} #{} {} alik.cz {} {} H{} :0 {}'.format(
                        IRC.RPL_WHOREPLY.value,
                        self.user,
                        room['id'],
                        nick['id'],
                        SERVER,
                        nick['name'],
                        '@' if nick['admin'] else '',
                        '{}, https://alik.cz/u/{}'.format(
                            nick['sex'],
                            nick['id'],
                        ),
                    ))
        else:
            nicks = dict()
            for room in rooms:
                for nick in room['users']:
                    if len(args) > 1 and args[1] == 'o' and not nick['admin']:
                        continue
                    nicks[nick['name']] = {
                        'link': nick['id'],
                        'sex': nick['sex'],
                    }
            for nick, data in sorted(nicks.items()):
                if not mask.match(nick) and \
                    not mask.match(data['link']) and \
                    not mask.match(data['sex']):
                    continue
                self.reply('{} {} * {} alik.cz {} {} H :0 {}'.format(
                    IRC.RPL_WHOREPLY.value,
                    self.user,
                    data['link'],
                    SERVER,
                    nick,
                    '{}, https://alik.cz/u/{}'.format(
                        data['sex'],
                        data['link'],
                    ),
                ))
        self.reply('{} {} {} :End of /WHO list.'.format(
            IRC.RPL_ENDOFWHO.value,
            self.user,
            args[0],
        ))

    # TODO: Implement this
    def handle_whois(self, args):
        """Handle WHOIS commands.

        Not implemented.

        :param args: [target] <mask>[,<mask>]*
        """
        logger.debug('handle_whois: {}'.format(args))
        self.error(IRC.ERR_UNKNOWNCOMMAND)

    # TODO: Implement this
    def handle_whowas(self, args):
        """Handle WHOWAS commands.

        Not implemented.

        :param args: <nick>[,<nick>]* [<count> [<target>]]
        """
        logger.debug('handle_whowas: {}'.format(args))
        self.error(IRC.ERR_UNKNOWNCOMMAND)

    def handle_kill(self, args):
        pass

    def handle_ping(self, args):
        """Handle PING commands.

        Respond with an appropriate PONG.  Since we are a virtual
        server, we speak for all of them.  In the two argument form,
        the first argument is the origin, such as the user name or
        another server, and the other argument is the target.

        In a single argument form, only the target is given.

        :param args: <server> [<server>]
        """
        logger.debug('handle_ping: {}'.format(args))
        self.reply('PONG {}'.format(
            SERVER,
        ))

    def handle_pong(self, args):
        """Handle PONG commands.

        Responses to PINGs.  We don't send any PINGs but it's okay
        if the client somehow sends these.  Just drop them.

        :param args: <server> [<server>]
        """
        logger.debug('handle_pong: {}'.format(args))
        return

    def handle_error(self, args):
        """Handle ERROR commands.

        The ERROR command is only supposed to be sent by servers, not
        clients.  There are no defined numerics for responses to these.
        We could send ERR_UNKNOWNCOMMAND, but since we're handling it,
        we'll just ignore it.

        :param args: <message>
        """
        logger.debug('handle_error: {}'.format(args))

    def handle_away(self, args):
        pass

    def handle_rehash(self, args):
        pass

    def handle_die(self, args):
        pass

    def handle_restart(self, args):
        pass

    def handle_summon(self, args):
        pass

    def handle_users(self, args):
        pass

    def handle_wallops(self, args):
        pass

    def handle_userhost(self, args):
        pass

    def handle_ison(self, args):
        pass

def sanitize(nick):
    """Sanitize nicks that are not generally acceptable
    or break the IRC protocol.

    Namly this replaces spaces with underscores.

    :param nick: The original nickname
    :returns: Modified nickname
    """
    return nick.replace(' ', '_')

def emoji(msg):
    """Replace Alík's emoticons with corresponding emojis.
    These are not exact match but are close enough.

    :param msg: The original message
    :returns: Message with emoji substitutions
    """
    msg = msg.replace('[:-)]', '🙂')
    msg = msg.replace('[:->]', '😀')
    msg = msg.replace('[:-D]', '😆')
    msg = msg.replace('[;-D]', '🤣')
    msg = msg.replace('[;-)]', '😉')
    msg = msg.replace('[:-|]', '😐')
    msg = msg.replace('[:-P]', '😛')
    msg = msg.replace('[8-D]', '😂')
    msg = msg.replace('[8-o]', '😲')
    msg = msg.replace('[:-o]', '😮')
    msg = msg.replace('[:-(]', '😟')
    msg = msg.replace('[:-E]', '😡')
    msg = msg.replace('[;-(]', '😢')
    msg = msg.replace('[:-c]', '😩')
    msg = msg.replace('[:-Q]', '🤮')
    msg = msg.replace('[8-P]', '😜')
    msg = msg.replace('[:-3]', '😊')
    msg = msg.replace('[:-$]', '🤢')
    msg = msg.replace('[O:-)]', '😇')
    msg = msg.replace('[]:-)]', '😈')
    msg = msg.replace('[Z]', '⚡')
    msg = msg.replace('[?]', '❓')
    msg = msg.replace('[!]', '❗')
    msg = msg.replace('[R^]', '👍')
    msg = msg.replace('[Rv]', '👎')
    msg = msg.replace('[O=]', '💡')
    msg = msg.replace('[@)->-]', '🌹')
    msg = msg.replace('[@=]', '💣')
    msg = msg.replace('[8=]', '💀')
    msg = msg.replace('[$>]', '💗')
    msg = msg.replace('B-)', '😎')
    msg = msg.replace(':-[)', '😷')
    msg = msg.replace('8-[)', '😷')
    msg = msg.replace('(8:O)', '🦛')
    msg = msg.replace('(8:o)', '🦛')
    msg = msg.replace('(8:°)', '🦛')
    msg = msg.replace('(ÍÍÍ)', '🍰')
    return msg

def accept(sock):
    """Accept new connections.

    Accepts all incoming connections, configures them as non-blocking and
    registers them with our master selector.

    Creates a buffer and a Client instance for each connection.

    :param sock: Listening socket with the pending connection request
    """
    conn = sock.accept()[0]
    conn.setblocking(False)
    sel.register(
        conn,
        (selectors.EVENT_READ),
        data=types.SimpleNamespace(buf=b'', client=Client(conn))
    )

def handle(key, mask):
    """Handle read evenets from the selector.

    Reads all pending data into a buffer, splitting it by CRLF to generate
    IRC messages.  These are later passed to Client.handle().

    Closes sockets and unregisters them from the selector when appropriate.

    :param key: The selector key object
    :param mask: The selector event mask
    """
    sock = key.fileobj
    data = key.data
    if mask & selectors.EVENT_READ:
        recv = sock.recv(BUFFER)
        if recv:
            data.buf += recv
        else:
            sel.unregister(sock)
            sock.close()
    while data.buf:
        pos = data.buf.find(b'\r\n')
        if pos != -1:
            cmd = data.buf[0:pos]
            data.buf = data.buf[pos + 2:]
            data.client.handle(cmd)
            continue
        break

def main():
    """The main body of the application.

    Sets everything up and begins listening for connections.

    Relies on selectors for input.
    """
    logger.setLevel(logging.DEBUG)
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind(('0.0.0.0', 6667))
    sock.listen()
    sock.setblocking(False)
    sel.register(sock, selectors.EVENT_READ, data=None)
    while True:
        events = sel.select(timeout=None)
        for k, m in events:
            if k.data is None:
                accept(k.fileobj)
            else:
                handle(k, m)

if __name__ == '__main__':
    main()
