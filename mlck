#!/usr/bin/python3
"""A virtual IRC server and a Malíček client.

This module provides an IRC interface for Malíček.  The connected
user is the only real user on the server, while everyone else is
virtual, as reported by the backend.

Periodically fetches new messages for joined channels.  Simulates
actions from other users.

Strives for full RFC 2812 compatibility.
"""

import argparse
import configparser
import enum
import logging
import os
import random
import re
import selectors
import socket
import string
import sys
import threading
import time
import types

import requests

# Version
VERSION = '0.1.0'
# User agent for requests
AGENT = 'mlck/{}'.format(VERSION)
# Startup timestamp
STARTED = time.strftime('%a %b %d %Y at %H:%M:%S UTC', time.gmtime())

logging.basicConfig(format='%(asctime)s : %(levelname)s : %(funcName)s: %(message)s')

# Global config
config = dict()
# Global logger
logger = logging.getLogger(__name__)
# Global selector
sel = selectors.DefaultSelector()

class IRC(enum.Enum):
    """Provides IRC response code mappings.

    An enum class, it holds response codes for each defined IRC
    keyword response.  Helps with readability.  Only the actual
    codes are sent, however.

    Based on RFC 2812.
    """
    RPL_WELCOME = '001'
    RPL_YOURHOST = '002'
    RPL_CREATED = '003'
    RPL_MYINFO = '004'
    RPL_BOUNCE = '005'
    RPL_TRACELINK = '200'
    RPL_TRACECONNECTING = '201'
    RPL_TRACEHANDSHAKE = '202'
    RPL_TRACEUNKNOWN = '203'
    RPL_TRACEOPERATOR = '204'
    RPL_TRACEUSER = '205'
    RPL_TRACESERVER = '206'
    RPL_TRACESERVICE = '207'
    RPL_TRACENEWTYPE = '208'
    RPL_TRACECLASS = '209'
    RPL_TRACERECONNECT = '210'
    RPL_STATSLINKINFO = '211'
    RPL_STATSCOMMANDS = '212'
    RPL_ENDOFSTATS = '219'
    RPL_STATSUPTIME = '242'
    RPL_STATSONLINE = '243'
    RPL_UMODEIS = '221'
    RPL_SERVLIST = '234'
    RPL_SERVLISTEND = '235'
    RPL_LUSERCLIENT = '251'
    RPL_LUSEROP = '252'
    RPL_LUSERUNKNOWN = '253'
    RPL_LUSERCHANNELS = '254'
    RPL_LUSERME = '255'
    RPL_ADMINME = '236'
    RPL_ADMINLOC1 = '257'
    RPL_ADMINLOC2 = '258'
    RPL_ADMINEMAIL = '259'
    RPL_TRACELOG = '261'
    RPL_TRACEEND = '262'
    RPL_TRYAGAIN = '263'
    RPL_AWAY = '301'
    RPL_USERHOST = '302'
    RPL_ISON = '303'
    RPL_UNAWAY = '305'
    RPL_NOWAWAY = '306'
    RPL_WHOISUSER = '311'
    RPL_WHOISSERVER = '312'
    RPL_WHOISOPERATOR = '313'
    RPL_WHOWASUSER = '314'
    RPL_ENDOFWHO = '315'
    RPL_WHOISIDLE = '317'
    RPL_ENDOFWHOIS = '318'
    RPL_WHOISCHANNELS = '319'
    RPL_LISTSTART = '321'
    RPL_LIST = '322'
    RPL_LISTEND = '323'
    RPL_CHANNELMODEIS = '324'
    RPL_UNIQOPIS = '325'
    RPL_NOTOPIC = '331'
    RPL_TOPIC = '332'
    RPL_INVITING = '341'
    RPL_SUMMONING = '342'
    RPL_INVITELIST = '346'
    RPL_ENDOFINVITELIST = '347'
    RPL_EXCEPTLIST = '348'
    RPL_ENDOFEXCEPTLIST = '349'
    RPL_VERSION = '351'
    RPL_WHOREPLY = '352'
    RPL_NAMEREPLY = '353'
    RPL_LINKS = '364'
    RPL_ENDOFLINKS = '365'
    RPL_ENDOFNAMES = '366'
    RPL_BANLIST = '367'
    RPL_ENDOFBANLIST = '368'
    RPL_ENDOFWHOWAS = '369'
    RPL_INFO = '371'
    RPL_MOTD = '372'
    RPL_ENDOFINFO = '374'
    RPL_MOTDSTART = '375'
    RPL_ENDOFMOTD = '376'
    RPL_YOUREOPER = '381'
    RPL_REHASHING = '382'
    RPL_YOURESERVICE = '383'
    RPL_TIME = '391'
    RPL_USERSSTART = '392'
    RPL_USERS = '393'
    RPL_ENDOFUSERS = '394'
    RPL_NOUSERS = '395'
    ERR_NOSUCHNICK = '401'
    ERR_NOSUCHSERVER = '402'
    ERR_NOSUCHCHANNEL = '403'
    ERR_CANNOTSENDTOCHAN = '404'
    ERR_TOOMANYCHANNELS = '405'
    ERR_WASNOSUCHNICK = '406'
    ERR_TOOMANYTARGETS = '407'
    ERR_NOSUCHSERVICE = '408'
    ERR_NOORIGIN = '409'
    ERR_NORECIPIENT = '411'
    ERR_NOTEXTTOSEND = '412'
    ERR_NOTOPLEVEL = '413'
    ERR_WILDTOPLEVEL = '414'
    ERR_BADMASK = '415'
    ERR_UNKNOWNCOMMAND = '421'
    ERR_NOMOTD = '422'
    ERR_NOADMININFO = '423'
    ERR_FILEERROR = '424'
    ERR_NONICKNAMEGIVEN = '431'
    ERR_ERRONEUSNICKNAME = '432'
    ERR_NICKNAMEINUSE = '433'
    ERR_NICKCOLLISION = '436'
    ERR_UNAVAILRESOURCE = '437'
    ERR_USERNOTINCHANNEL = '441'
    ERR_NOTONCHANNEL = '442'
    ERR_USERONCHANNEL = '443'
    ERR_NOLOGIN = '444'
    ERR_SUMMONDISABLED = '445'
    ERR_USERSDISABLED = '446'
    ERR_NOTREGISTERED = '451'
    ERR_NEEDMOREPARAMS = '461'
    ERR_ALREADYREGISTERED = '462'
    ERR_NOPERMFORHOST = '463'
    ERR_PASSWDMISMATCH = '464'
    ERR_YOUREBANNEDCREEP = '465'
    ERR_YOUWILLBEBANNED = '466'
    ERR_KEYSET = '467'
    ERR_CHANNELISFULL = '471'
    ERR_UNKNOWNMODE = '472'
    ERR_INVITEONLYCHAN = '473'
    ERR_BANNEDFROMCHAN = '474'
    ERR_BADCHANNELKEY = '475'
    ERR_BADCHANMASK = '476'
    ERR_NOCHANMODES = '477'
    ERR_BANLISTFULL = '478'
    ERR_NOPRIVILEGES = '481'
    ERR_CHANOPRIVSNEEDED = '482'
    ERR_CANTKILLSERVER = '483'
    ERR_RESTRICTED = '484'
    ERR_UNIQOPPRIVSNEEDED = '485'
    ERR_NOOPERHOST = '491'
    ERR_UMODEUNKNOWNFLAG = '501'
    ERR_USERSDONTMATCH = '502'

class Client:
    """Provides an abstraction of the connection session.

    Instances represent each individual connection, hold its client socket,
    Malíček session, and various collected metadata.
    """
    def __init__(self, sock):
        """Class constructor.

        Initializes instance variables; these include the socket reference,
        the endpoint, the Malíček session reference, the user nickname, their
        password, the channels they've joined, information about other nicks
        they've collected, the automatic periodic thread reference, and thread
        locks for shared resources.

        Requires the socket reference.

        The default nickname is '*', as per RFC 2812.

        :param sock: The socket reference of this connection
        :returns: A Client instance
        """
        self.socket = sock
        self.session = None
        self.user = '*'
        self.password = None
        self.userstring = None
        # Dict of channels we're in
        # Values are another dict, with `seen` and `activity` as keys
        self.channels = dict()
        # All users we know about, userful for user IDs in JOIN & PART,
        # and potentially also for WHO, WHOIS, NAMES and ISON
        self.nicks = dict()
        # Our auto thread for fetching messages and other updates
        self.auto = threading.Thread(target=self.periodic, daemon=True)
        # Locks for commonly accessed shared resources
        self.lock = {
            x: threading.Lock() for x in (
                'channels',
                'nicks',
            )
        }

    def __del__(self):
        """Destroys the session instance.

        Attempts to log off, properly destroys the session and clears the
        Client.periodic() thread.  Called automatically by GC.
        """
        if self.registered():
            self.logout()
            self.session = None
            self.auto.join()

    def setup(self):
        """Creates an instance of the session.

        Automatically logs in and maintains the session cookie.  Clears the
        session upon failure not to confuse Client.registered().

        :returns: True on success, False otherwise
        """
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': AGENT,
        })
        if self.login():
            self.auto.start()
            return True
        self.session = None
        return False

    # TODO: Check if the message begins with an originator
    #       and if so, strip it.
    def handle(self, msg):
        """Consume messages from the socket.

        The class entry point.  Messages extracted from the socket stream
        are passed to this method as a byte sequence.

        Decodes the input, splits it into commands and arguments, and directs
        the data to respective handlers.

        Provides very basic checking for sanity.

        :param msg: Byte sequence representing message input
        """
        msg = msg.decode(config['encoding'])
        pos = msg.find(' ')
        if pos == -1:
            cmd = msg
            args = None
        else:
            cmd = msg[0:pos]
            args = msg[pos + 1:]
        if not cmd:
            return
        cmd = str.upper(cmd)
        if cmd == 'PASS':
            logger.debug('%s, ***', cmd)
        else:
            logger.debug('%s, %s', cmd, args)
        if self.registered() and cmd in ('NICK', 'USER', 'PASS'):
            self.error(IRC.ERR_ALREADYREGISTERED)
            return
        if not self.registered() and cmd not in ('NICK', 'USER', 'PASS'):
            self.error(IRC.ERR_NOTREGISTERED)
            return
        if cmd == 'PASS':
            self.handle_pass(args)
        elif cmd == 'USER':
            self.handle_user(args)
        elif cmd == 'NICK':
            self.handle_nick(args)
        elif cmd == 'OPER':
            self.handle_oper(args)
        elif cmd == 'MODE':
            self.handle_mode(args)
        elif cmd == 'SERVICE':
            self.handle_service(args)
        elif cmd == 'QUIT':
            self.handle_quit(args)
        elif cmd == 'SQUIT':
            self.handle_squit(args)
        elif cmd == 'JOIN':
            self.handle_join(args)
        elif cmd == 'PART':
            self.handle_part(args)
        elif cmd == 'TOPIC':
            self.handle_topic(args)
        elif cmd == 'NAMES':
            self.handle_names(args)
        elif cmd == 'LIST':
            self.handle_list(args)
        elif cmd == 'INVITE':
            self.handle_invite(args)
        elif cmd == 'KICK':
            self.handle_kick(args)
        elif cmd == 'PRIVMSG':
            self.handle_privmsg(args)
        elif cmd == 'NOTICE':
            self.handle_notice(args)
        elif cmd == 'MOTD':
            self.handle_motd(args)
        elif cmd == 'LUSERS':
            self.handle_lusers(args)
        elif cmd == 'VERSION':
            self.handle_version(args)
        elif cmd == 'STATS':
            self.handle_stats(args)
        elif cmd == 'LINKS':
            self.handle_links(args)
        elif cmd == 'TIME':
            cmd.handle_time(args)
        elif cmd == 'CONNECT':
            cmd.handle_connect(args)
        elif cmd == 'TRACE':
            cmd.handle_trace(args)
        elif cmd == 'ADMIN':
            self.handle_admin(args)
        elif cmd == 'INFO':
            self.handle_info(args)
        elif cmd == 'SERVLIST':
            self.handle_servlist(args)
        elif cmd == 'SQUERY':
            self.handle_squery(args)
        elif cmd == 'WHO':
            self.handle_who(args)
        elif cmd == 'WHOIS':
            self.handle_whois(args)
        elif cmd == 'WHOWAS':
            self.handle_whowas(args)
        elif cmd == 'KILL':
            self.handle_kill(args)
        elif cmd == 'PING':
            self.handle_ping(args)
        elif cmd == 'PONG':
            self.handle_pong(args)
        elif cmd == 'ERROR':
            self.handle_error(args)
        elif cmd == 'AWAY':
            self.handle_away(args)
        elif cmd == 'REHASH':
            self.handle_rehash(args)
        elif cmd == 'DIE':
            self.handle_die(args)
        elif cmd == 'RESTART':
            self.handle_restart(args)
        elif cmd == 'SUMMON':
            self.handle_summon(args)
        elif cmd == 'USERS':
            self.handle_users(args)
        elif cmd == 'WALLOPS':
            self.handle_wallops(args)
        elif cmd == 'USERHOST':
            self.handle_userhost(args)
        elif cmd == 'ISON':
            self.handle_ison(args)
        else:
            self.error(IRC.ERR_UNKNOWNCOMMAND)
            logger.warning('Unknown command: %s, args: %s', cmd, args)

    def reply(self, msg):
        """Send a standard reply in response to a command.

        Only so slightly simplifies sending code responses back to the client.
        The method only prefixes each message with the server name.

        Unfortunately, as each message has a different format, this is the
        best we can currently offer.

        The message must include everything to be sent: the code, the possible
        arguments, additional human readable messages and more.

        :param msg: The message to send
        """
        logger.debug(msg)
        self.socket.sendall(
            ':{} '.format(config['server']).encode(config['encoding']) + \
            msg.encode(config['encoding']) + \
            b'\r\n'
        )

    def error(self, err, response=None):
        """Send an error reply in response to a command.

        Simplifies error responses.  The response message is optional and
        standard messages for the given error codes are used, if known.

        If not, the default error message is the error code constant.

        This is nott he same as the ERROR command.  For that one, refer
        to Client.do_error().

        :param err: The error code, an enum of the IRC class
        :param response: Optional error message
        """
        logger.debug('%s, %s', err, response)
        if err == IRC.ERR_NEEDMOREPARAMS:
            response = response or 'Not enough parameters given.'
        elif err == IRC.ERR_UNKNOWNCOMMAND:
            response = response or 'Command not implemented.'
        elif err == IRC.ERR_PASSWDMISMATCH:
            response = response or 'Authentication failed, sorry.'
        elif err == IRC.ERR_ALREADYREGISTERED:
            response = response or 'You are already logged in.'
        elif err == IRC.ERR_NOTREGISTERED:
            response = response or 'You must log in to continue.'
        elif err == IRC.ERR_NOSUCHNICK:
            respose = respose or 'Private messaging is unsupported.'
        elif err == IRC.ERR_NOTEXTTOSEND:
            response = response or 'No message specified.'
        elif err in (IRC.ERR_CANNOTSENDTOCHAN, IRC.ERR_NOTONCHANNEL):
            response = response or 'You must join the channel first.'
        elif err == IRC.ERR_NOPRIVILEGES:
            response = response or 'You are not allowed to do that here.'
        response = response or err
        self.reply('{} {} :{}'.format(
            err.value,
            self.user,
            response,
        ))

    # TODO: Handle room errors
    # TODO: Handle channel modes
    def periodic(self):
        """Automatic periodic check of active channels.

        Periodically checks all channels the user has joined, querying for
        new messages, users joining or parting, mode changes and more.

        Triggers relevant IRC actions to simulate the activity.  Maintains
        presence via keepalive calls, whenever required.

        The backbone of mlck.  Runs in an idependent thread.

        Note this holds the global channels lock.
        """
        while self.registered():
            self.lock['channels'].acquire()
            for chan in self.channels:
                logger.debug(chan)
                res = self.get('rooms/{}'.format(chan[1:]))
                if not res:
                    continue
                res = res.json()
                messages = list()
                for msg in res['messages']:
                    if msg == self.channels[chan]['seen']:
                        break
                    messages.append(msg)
                messages.reverse()
                if messages:
                    self.channels[chan]['seen'] = messages[-1]
                ctime = int(time.time())
                if ctime - self.channels[chan]['activity'] > 15 * 60:
                    if self.keepalive(chan):
                        self.channels[chan]['activity'] = ctime
                self.channels[chan]['topic'] = '{}{}'.format(
                    res['name'],
                    ' | {}'.format(res['topic']) if res['topic'] else '',
                )
                for usr in res['users']:
                    self.info(
                        usr['name'],
                        uid=usr['id'],
                        link=usr['link'],
                        sex=usr['sex'],
                        age=usr['age'],
                        oper=bool(usr['admin']),
                    )
                for msg in messages:
                    if msg['nick'] == self.user:
                        continue
                    if msg['type'] == 'system':
                        if msg['event']['type'] == 'join':
                            self.do_join(
                                msg['event']['source'],
                                chan,
                            )
                            continue
                        if msg['event']['type'] == 'part' or msg['event']['type'] == 'kick':
                            self.do_part(
                                msg['event']['source'] or msg['event']['target'],
                                chan,
                                msg['message'],
                            )
                            continue
                    self.do_privmsg(
                        msg['nick'] if msg['nick'] else '*',
                        chan,
                        emoji(msg['message']) if not msg['private'] else '\x02[{}, pst!] {}\x0f'.format(', '.join(msg['private']), emoji(msg['message']))
                    )
            self.lock['channels'].release()
            time.sleep(config['refresh'])

    def keepalive(self, chan):
        """Send a keepalive message.

        Generates a simple, hopefully unique keepalive message and sends it
        as a broken private message to the channel of choice.

        Prevents idling out even when inactive.

        The message takes form of "[ malíček/keepalive <16 bytes of hex> ]".

        :param chan: Channel name
        """
        logger.debug(chan)
        msg = '[ malíček/keepalive {} ]'.format(
            str.lower(''.join(random.choice(string.hexdigits) for i in range(16)))
        )
        return self.post(
            'rooms/{}'.format(chan[1:]),
            data={
                'action': 'post',
                'to': -1,
                'message': msg,
                'color': self.channels[chan]['color'],
            },
        )

    def info(self, nick, uid=None, link=None, sex=None, age=None, oper=None):
        """Handle user information records

        Fetch and, optionally, store user details.  Different handles provide
        different details we may want to gather over time.

        Returns a dictionary of all the data configured for a given nicknames
        so far.  Keys include uid (the numerical system ID), link (the string
        form of the ID, sanitized nickname), sex, age and oper (True if the
        user is a moderator).

        :param nick: Nickname to query or update
        :param uid: Optional, save the numerical uid
        :param link: Optional, save the string id
        :param sex: Optional, save the sex
        :param age: Optional, save age
        :param oper: Optional, save the operator status
        :returns: A dictionary of all stored values
        """
        with self.lock['nicks']:
            if nick not in self.nicks:
                self.nicks[nick] = {
                    x: None for x in ('uid', 'link', 'sex', 'age', 'oper')
                }
            if uid:
                self.nicks[nick]['uid'] = uid
            if link:
                self.nicks[nick]['link'] = link
            if sex:
                self.nicks[nick]['sex'] = sex
            if age:
                self.nicks[nick]['age'] = age
            if oper:
                self.nicks[nick]['oper'] = oper
            return self.nicks[nick]

    def register(self):
        """Register a connection.

        Attempt to register the connection if all required data has been
        provided.  Called from handle_nick() and handle_user().
        """
        if self.user == '*' or not self.password or not self.userstring:
            return
        if self.setup():
            self.reply('{} {} :Welcome to Malíček.'.format(
                IRC.RPL_WELCOME.value,
                self.user,
            ))
            self.reply('{} {} :Your host is {}, running version mlck-{}.'.format(
                IRC.RPL_YOURHOST.value,
                self.user,
                config['server'],
                VERSION,
            ))
            self.reply('{} {} :This server was created on {}'.format(
                IRC.RPL_CREATED.value,
                self.user,
                STARTED,
            ))
            # TODO: Advertise modes once we support them
            self.reply('{} {} :{} mlck-{}'.format(
                IRC.RPL_MYINFO.value,
                self.user,
                config['server'],
                VERSION,
            ))
        else:
            self.error(IRC.ERR_PASSWDMISMATCH)
            sel.unregister(self.socket)
            self.socket.close()

    def registered(self):
        """Check if our connection has been registered.

        Most of our functionality depends on having a registered session.
        This method checks whether we have one.

        :returns: True if we have a working session, False otherwise
        """
        if self.session:
            return True
        return False

    def get(self, resource, params=None):
        """Fetch Malíček resources using GET.

        A simple wrapper for fetching backend resources.  Returns raw request
        response objects.  Callers may check the status code or extract the data
        using the json() method.

        :param resource: API resource, appended to the endpoint
        :returns: Request response object
        """
        try:
            response = self.session.get(
                '{}/{}'.format(config['endpoint'], resource),
                timeout=config['timeout'],
                params=params,
            )
            response.encoding = 'utf-8'
            return response
        except requests.exceptions.Timeout:
            logger.warning('get: timeout while processing %s, params: %s', resource, params)
            return None

    def post(self, resource, params=None, data=None):
        """Fetch Malíček resources using POST

        A simple wrapper for fetching backend resources.  Returns raw request
        response objects.  Callers may check the status code or extract the data
        using the json() method.

        Optionally, a data structure can be passed representing the data to
        send.

        :param resource: API resource, appended to the endpoint
        :param data: Data to send, if any
        :returns: Request response object
        """
        try:
            response = self.session.post(
                '{}/{}'.format(config['endpoint'], resource),
                timeout=config['timeout'],
                params=params,
                json=data,
            )
            response.encoding = 'utf-8'
            return response
        except requests.exceptions.Timeout:
            logger.warning('post: timeout while processing %s, params: %s', resource, params)
            return None

    def login(self):
        """Initiate the Malíček session.

        Calls the /login resource, creating the session.  Having one is
        generally required for almost everything else.  Only works after
        PASS and NICK.  Should be called after USER.

        Clears the password from memory.

        :returns: True if we managed to log in, False otherwise
        """
        logger.debug(self.user)
        r = self.post(
            'login',
            data={
                'user': self.user,
                'pass': self.password
            }
        )
        self.password = None
        return r and r.status_code == requests.codes.ok

    def logout(self):
        """Terminate the Malíček session.

        Calls the /logout resource.  The only real use is a cleanup, so
        this gets called from the destructor.
        """
        logger.debug(self.user)
        self.get('logout')

    def rooms(self):
        """Fetch the /rooms resource.

        This is a shorthand for fetching the list of rooms.

        :returns: Request response
        """
        logger.debug('-')
        rooms = self.get('rooms')
        return rooms.json() if rooms else None

    def do_privmsg(self, sender, target, message):
        """Send the PRIVMSG command.

        Sends a PRIVMSG message on behalf of the sender.

        The sender is the sender's nickname, which is translated into a
        virtual username formed from the link ID + @alik.cz.  If the link
        ID is unavailable, *@alik.cz is used instead.

        In the rare event of sending PART of behalf of *, don't do any
        user mangling.

        :param sender: The messaging person, their NICK
        :param target: The target, typically a channel
        :param message: The message to send
        """
        logger.debug('%s, %s, %s', sender, target, message)
        if sender != '*':
            sender = '{}!{}@alik.cz'.format(sender, self.info(sender)['link'] or '*')
        self.socket.sendall(':{} PRIVMSG {} :{}'.format(
                sender,
                target,
                message,
            ).encode(config['encoding']) + \
            b'\r\n'
        )

    def do_notice(self, sender, target, message):
        """Send the NOTICE command.

        Sends a NOTICE message on behalf of the sender.

        The sender is the sender's nickname, which is translated into a
        virtual username formed from the link ID + @alik.cz.  If the link
        ID is unavailable, *@alik.cz is used instead.

        In the rare event of sending PART of behalf of *, don't do any
        user mangling.

        :param sender: The messaging person, their NICK
        :param target: The target, typically a channel
        :param message: The message to send
        """
        logger.debug('%s, %s, %s', sender, target, message)
        if sender != '*':
            sender = '{}!{}@alik.cz'.format(sender, self.info(sender)['link'] or '*')
        self.socket.sendall(':{} NOTICE {} :{}'.format(
                sender,
                target,
                message,
            ).encode(config['encoding']) + \
            b'\r\n'
        )

    def do_join(self, sender, channel):
        """Send the JOIN command.

        Sends JOIN to the channel on behalf of the sender.

        The sender is the sender's nickname, which is translated into a
        virtual username formed from the link ID + @alik.cz.  If the link
        ID is unavailable, *@alik.cz is used instead.

        In the rare event of sending PART of behalf of *, don't do any
        user mangling.

        :param sender: The joining person, their NICK
        :param channel: The channel they are joining
        """
        logger.debug('%s, %s', sender, channel)
        if sender != '*':
            sender = '{}!{}@alik.cz'.format(sender, self.info(sender)['link'] or '*')
        self.socket.sendall(':{} JOIN {}'.format(
                sender,
                channel,
            ).encode(config['encoding']) + \
            b'\r\n'
        )

    def do_part(self, sender, channel, msg=None):
        """Send the PART command.

        Sends PART to the channel on behalf of the sender, with an optional
        parting message.

        The sender is the sender's nickname, which is translated into a
        virtual username formed from the link ID + @alik.cz.  If the link
        ID is unavailable, *@alik.cz is used instead.

        In the rare event of sending PART of behalf of *, don't do any
        user mangling.

        :param sender: The leaving person, their NICK
        :param channel: The channel they are leaving
        :param msg: Optional parting message
        """
        logger.debug('%s, %s, %s', sender, channel, msg)
        if sender != '*':
            sender = '{}!{}@alik.cz'.format(sender, self.info(sender)['link'] or '*')
        self.socket.sendall(':{} PART {} :{}'.format(
                sender,
                channel,
                msg if msg else '',
            ).encode(config['encoding']) + \
            b'\r\n'
        )

    def do_error(self, message=None):
        """Send the ERROR command.

        These are emitted by the server under special circumstances and they
        always target our only user, self.user.

        Not to be used for ERR replies.  See Client.error() for those.

        If no message is specified, "An error is an error." is sent.

        :param message: The error message to send
        """
        logger.debug(message)
        message = message or 'An error is an error.'
        self.socket.sendall(':{} ERROR :{}'.format(
                config['server'],
                message,
            ).encode(config['encoding']) + \
            b'\r\n',
        )

    def handle_pass(self, args):
        """Handle PASS commands.

        Required for registering a session with us.  This needs to preceed
        the USER command which itself finishes the registration.

        :param args: <password>
        """
        logger.debug('***')
        if not args:
            self.error(IRC.ERR_NEEDMOREPARAMS)
            return
        self.password = args

    def handle_nick(self, args):
        """Handle NICK commands.

        Set the nickname and use it Alík's username.  It doesn't make
        sense to change it later as it's your immutable remote identifier.

        Attempts to register the connection.

        :param args: <nickname>
        """
        logger.debug(args)
        if not args:
            self.error(IRC.ERR_NEEDMOREPARAMS)
            return
        self.user = args
        self.register()

    def handle_user(self, args):
        """Handle USER commands.

        Finishes the registration.  We don't actually care about the
        arguments as all, so we ignore them all.  No one will see you.

        The arguments are effectively ignored but stored.

        Attempts to register the connection.

        :param args: <USER string>
        """
        logger.debug(args)
        if not args:
            self.error(IRC.ERR_NEEDMOREPARAMS)
            return
        self.userstring = args
        self.register()

    def handle_oper(self, args):
        """Handle OPER commands.

        Requires username + password but we don't really care.  We don't
        support server administration, so just reject everything.

        :param args: <username> <password>
        """
        logger.debug('***')
        if not args or args.find(' ') == -1:
            self.error(IRC.ERR_NEEDMOREPARAMS)
            return
        self.error(IRC.ERR_PASSWDMISMATCH)

    # TODO: Implement this
    def handle_mode(self, args):
        """Handle MODE commands.

        Sets user or channel modes.  With no modes, just queries the current
        modes.

        Currently we don't support any modes.

        In theory we could support an extremely limited subset of modes later.
        These would include:

            User mode w: Just our user; receives wallops or not

            Channel mode n: Must be a member to message
            Channel mode o: Query or set the channel operator, if possible
            Channel mode O: Query the channel creator
            Channel mode t: Must be the channel op to change toppic

        Users could manipulate the user mode 'w' and the channel mode 'o',
        assuming they're the operator.  They could query the channel mode 'O',
        but only if they're on that channel due to backend limitations.

        All channels could have the 'n' and 't' modes because that's just
        our reality.  Question is whether it's useful.

        :param args: <nick/channel> [<modes> [<params>]]
        """
        logger.debug(args)
        if not args:
            self.error(IRC.ERR_NEEDMOREPARAMS)
        self.error(IRC.ERR_UNKNOWNCOMMAND)

    def handle_service(self, args):
        """Handle SERVICE commands.

        Services don't make any sense in our context.  Parse the message but
        refuse to cooperate.

        :param args: <nickname> <reserved> <dist> <type> <reserved> <info>
        """
        logger.debug(args)
        if not args or args.count(' ') < 5:
            self.error(IRC.ERR_NEEDMOREPARAMS)
            return
        self.error(IRC.ERR_UNKNOWNCOMMAND)

    # TODO: Leave all channels once done debugging
    def handle_quit(self, args):
        """Handle QUIT commands.

        The client is quitting.  Part all the active channels, unregister
        our selector and close the socket, unless they've already done that.

        Except that we don't do part the channels yet.  It's too early in
        the development and it could hinder testing with unnecessary spam.
        """
        logger.debug(args)
        sel.unregister(self.socket)
        try:
            self.do_error('Buh-bye!')
            self.socket.close()
        except:
            pass

    def handle_squit(self, args):
        """Handle SQUIT commands.

        Used to close server-to-server links.  Makes zero sense in our
        context.  Parse the message but return a privilege error.  No one
        is an operator here.

        :param args: <server> <comment>
        """
        if not args or not args.count(' '):
            self.error(IRC.ERR_NEEDMOREPARAMS)
            return
        self.error(IRC.ERR_NOPRIVILEGES)

    # TODO: Backlog whispers
    def handle_join(self, args):
        """Handle JOIN commands.

        Attempts to join the specified channels.  Potential keys are
        of no use to us so they're ignored.  JOIN must be confirmed
        upon success.  The client should also receive the channel topic
        and the list of users, including self.  Additionaly, we also
        send all visible backlog messages as the '*' user.

        Joining "0" is an equivalent of parting all the currently joined
        channels.

        Joining with no arguments is non-standard but common.  We accept
        it and do nothing.

        :param args: [0|<channel>[,<channel>]* [<key>[,<key>]*]]
        """
        logger.debug(args)
        if not args:
            return
        if args == '0':
            self.lock['channels'].acquire()
            for chan in self.channels:
                if self.post(
                        'rooms/{}'.format(chan[1:]),
                        data={
                            'action': 'leave'
                        },
                    ):
                    del self.channels[chan]
                    self.do_part(self.user, chan)
                else:
                    self.error(
                        IRC.ERR_UNAVAILRESOURCE,
                        'Cannot leave {}, resource is temporarily unavailable.'.format(chan),
                    )
            self.lock['channels'].release()
            return
        for chan in args.split(' ')[0].split(','):
            res = self.get('rooms/{}'.format(chan[1:]))
            if not res:
                self.error(
                    IRC.ERR_UNAVAILRESOURCE,
                    'Cannot join {}, resource is temporarily unavailable.'.format(chan),
                )
                continue
            if res.status_code != 200:
                continue
            res = res.json()
            settings = self.get(
                'rooms/{}'.format(chan[1:]),
                params={
                    'query': 'settings',
            })
            if not settings:
                settings = {
                    'color': '#000000',
                }
            for usr in res['users']:
                self.info(
                    usr['name'],
                    uid=usr['id'],
                    link=usr['link'],
                    sex=usr['sex'],
                    age=usr['age'],
                    oper=bool(usr['admin']),
                )
            self.do_join(self.user, chan)
            topic = '{}{}'.format(
                res['name'],
                ' | {}'.format(res['topic']) if res['topic'] else '',
            )
            self.reply('{} {} {} :{}'.format(
                IRC.RPL_TOPIC.value,
                self.user,
                chan,
                topic,
            ))
            self.reply('{} {} = {} :{}'.format(
                IRC.RPL_NAMEREPLY.value,
                self.user,
                chan,
                ' '.join(
                    '{}{}'.format(
                        ('@' if x['admin'] else ''),
                        x['name'],
                    ) for x in res['users']
                )
            ))
            self.reply('{} {} {} :{}'.format(
                IRC.RPL_ENDOFNAMES.value,
                self.user,
                chan,
                'End of /NAMES list.',
            ))
            messages = res['messages']
            messages.reverse()
            for msg in messages:
                self.do_privmsg(
                    '*',
                    chan,
                    '[{}] ({}) {}'.format(
                        msg['time'] if msg['time'] else '??:??:??',
                        msg['nick'] if msg['nick'] else '*',
                        emoji(msg['message']),
                    ),
                )
            self.lock['channels'].acquire()
            self.channels[chan] = {
                'activity': int(time.time()),
                'color': settings.json()['color'],
                'topic': topic,
            }
            if messages:
                self.channels[chan]['seen'] = messages[-1]
            self.lock['channels'].release()

    def handle_part(self, args):
        """Handle PART commands.

        Leaves the selected list of channels.  We do not have to
        check their presence as the backend doesn't care, although
        we could potentially cut a few nonsensical requests.

        We don't have anywhere to send the parting message so we
        simply ignore it.

        :param args: <channel>[,<channel>]*[ :<message>]
        """
        logger.debug(args)
        if not args:
            self.error(IRC.ERR_NEEDMOREPARAMS)
            return
        for chan in args.split(' ')[0].split(','):
            self.lock['channels'].acquire()
            if self.post(
                    'rooms/{}'.format(chan[1:]),
                    data={
                        'action': 'leave'
                    },
                ):
                del self.channels[chan]
                self.do_part(self.user, chan)
            else:
                self.error(
                    IRC.ERR_UNAVAILRESOURCE,
                    'Cannot leave {}, resource is temporarily unavailable.'.format(chan),
                )
            self.lock['channels'].release()

    # TODO: Implement topic setting
    def handle_topic(self, args):
        """Handle TOPIC commands.

        Queries or sets the channel topic.  Setting the channel topic
        requires the channel operator status in all cases.

        Due to the current backend limitations, we can only query topics
        for channels the user has joined.

        :param args: <channel> [:<topic>]
        """
        logger.debug(args)
        if not args:
            self.error(IRC.ERR_NEEDMOREPARAMS)
            return
        if args.find(' ') != -1:
            self.error(
                IRC.ERR_UNKNOWNCOMMAND,
                'Setting channel modes is currently unsupported.',
            )
            return
        self.lock['channels'].acquire()
        if not args in self.channels:
            self.error(IRC.ERR_NOTONCHANNEL)
        else:
            self.reply('{} {} {} :{}'.format(
                IRC.RPL_TOPIC.value,
                self.user,
                args,
                self.channels[args]['topic'],
            ))
        self.lock['channels'].release()

    def handle_names(self, args):
        """Handle NAMES commands.

        The command provides yet another method to list users on the
        given channel or channels.

        Channels are optional.  With no arguments lists all the channels
        and their occupants.  Bad channel names are okay.

        Target doesn't make sense here, so we ignore it.

        :param args: [<channel>[,<channel>]* [<target>]]
        """
        logger.debug(args)
        rooms = self.rooms()
        if not rooms:
            self.error(
                IRC.ERR_UNAVAILRESOURCE,
                'Cannot fetch names, resource temporarily unavailable.',
            )
            return
        only = set()
        if args:
            only.update(x[1:] for x in args.split(','))
        for room in rooms:
            if not room['id']:
                continue
            if only and room['id'] not in only:
                continue
            self.reply('{} {} = #{} :{}'.format(
                IRC.RPL_NAMEREPLY.value,
                self.user,
                room['id'],
                ' '.join(
                    '{}{}'.format(
                        ('@' if x['admin'] else ''),
                        x['name'],
                    ) for x in room['users']
                ),
            ))
            self.reply('{} {} #{} :{}'.format(
                IRC.RPL_ENDOFNAMES.value,
                self.user,
                room['id'],
                'End of NAMES list.',
            ))

    # TODO: Add topic to name (blocked by Malicek support)
    def handle_list(self, args):
        """Handle LIST commands.

        Queries existing channels.  Lists all channels without
        arguments, or limits the output to channels that match one
        of the provided channel names.  These may contain the '*'
        wildcard, which we translate to '.*' in a regex.

        The optional target argument is ignored.

        The output includes the number of users in that channel,
        as well as its actual name.

        Rooms the user cannot join are not listed as the have no
        known ID.

        :param args: [<channel>[,<channel>]* [<target>]]
        """
        logger.debug(args)
        only = set()
        if args:
            for pattern in args.split(' ')[0].split(','):
                pattern = re.escape(pattern)
                pattern = pattern.replace('\\#', '#')
                pattern = pattern.replace('\\?', '.')
                pattern = pattern.replace('\\*', '.*')
                only.add(re.compile('^{}$'.format(pattern)))
        rooms = self.rooms()
        if not rooms:
            self.error(
                IRC.ERR_UNAVAILRESOURCE,
                'Cannot process rooms, resource is temporarily unavailable.',
            )
            return
        for room in rooms:
            show = True
            if only:
                show = False
                for pattern in only:
                    if pattern.match(room['id']):
                        show = True
                        break
            if room['id'] is None:
                show = False
            if not show:
                continue
            self.reply('{} {} #{} {} :{}'.format(
                IRC.RPL_LIST.value,
                self.user,
                room['id'],
                len(room['users']),
                room['name'],
            ))
        self.reply('{} {} :End of LIST'.format(
            IRC.RPL_LISTEND.value,
            self.user,
        ))

    def handle_invite(self, args):
        pass

    def handle_kick(self, args):
        pass

    # TODO: Handle whispering
    def handle_privmsg(self, args):
        """Handle PRIVMSG commands.

        The standard IRC messaging method, sends commands to channels
        or users.  Due to Alík's limitations, private messages cannot
        work outside of channels.  Messaging users is therefore disabled.

        Sending messages to channels one hasn't joined is similarly
        impossible and returns an error.

        ACTION messages are converted to "*<text>*" and sent as regular
        messages instead.  SOH is stripped.

        :param args: <msgtarget> <text>
        """
        logger.debug(args)
        if not args:
            self.error(IRC.ERR_NEEDMOREPARAMS)
            return
        chan, msg = args.split(' ', 1)
        if not chan.startswith('#'):
            self.error(IRC.ERR_NOSUCHNICK)
            return
        if len(msg) < 2:
            self.error(IRC.ERR_NOTEXTTOSEND)
            return
        self.lock['channels'].acquire()
        if chan not in self.channels:
            self.error(IRC.ERR_CANNOTSENDTOCHAN)
            return
        msg = msg[1:]
        if msg.startswith('\x01') and msg.endswith('\x01'):
            msg = msg.replace('\x01ACTION ', '*')
            msg = msg.replace('\x01', '*')
        if self.post(
                'rooms/{}'.format(chan[1:]),
                data={
                    'action': 'post',
                    'to': 0,
                    'message': msg,
                    'color': self.channels[chan]['color'],
                },
            ):
            self.channels[chan]['activity'] = int(time.time())
        else:
            self.error(
                IRC.ERR_UNAVAILRESOURCE,
                'Message ({}, {}) not send; resource temporarily unavailable.'.format(
                    chan,
                    msg,
                ),
            )
        self.lock['channels'].release()

    def handle_notice(self, args):
        """Handle NOTICE commands.

        This just calls handle_privmsg() as they're virtually
        identical in our context.

        :param args: <msgtarget> <text>
        """
        logger.debug(args)
        self.handle_privmsg(args)

    def handle_motd(self, args):
        pass

    def handle_lusers(self, args):
        pass

    def handle_version(self, args):
        pass

    def handle_stats(self, args):
        pass

    def handle_links(self, args):
        pass

    def handle_time(self, args):
        pass

    def handle_connect(self, args):
        pass

    def handle_trace(self, args):
        pass

    def handle_admin(self, args):
        pass

    def handle_info(self, args):
        pass

    def handle_servlist(self, args):
        pass

    def handle_squery(self, args):
        pass

    # TODO: Age requires a Malicek update
    def handle_who(self, args):
        """Handle WHO commands.

        RFC 2812 is rather vague and unclear on this topic, however, WHO
        commands require one or two arguments, the first of which is a mask,
        the other is optionally the letter 'o'.

        The mask can be both a user mask or a channel mask and may include
        wildcards.

        We support this, except that if the mask begins with a '#', channel
        is assumed, user otherwise.  To search for channels beginning with a
        wildcard, '#*foo' must be requested.

        If 'o' is requested, the list returns only operators.

        For channels, we query every matching channel.  For user queries we
        aggregate the results and return them for channel '*', omitting
        operator flags.  This seems to be the common practice.

        The "real name" part is replaced by user details for convenience.

        User mask doesn't match against our virtual hostnames or servers,
        only IDs, nicknames and details.

        Channel queries omit channels the user cannot join as they have
        no visible room IDs.

        :param args: [<mask> [o]]
        """
        logger.debug(args)
        args = args or ''
        rooms = self.rooms()
        if not rooms:
            self.error(
                IRC.ERR_UNAVAILRESOURCE,
                'Cannot list users, resource is temporarily unavailable.',
            )
            return
        args = args.split(' ')
        if args[0] in ('', '0'):
            args[0] = '*'
        mask = re.escape(args[0])
        mask = mask.replace('\\#', '#')
        mask = mask.replace('\\?', '.')
        mask = mask.replace('\\*', '.*')
        mask = re.compile('^{}$'.format(mask))
        if args[0].startswith('#'):
            for room in rooms:
                if not room['id'] or not mask.match('#{}'.format(room['id'])):
                    continue
                for nick in room['users']:
                    if len(args) > 1 and args[1] == 'o' and not nick['admin']:
                        continue
                    self.reply('{} {} #{} {} alik.cz {} {} H{} :0 {}'.format(
                        IRC.RPL_WHOREPLY.value,
                        self.user,
                        room['id'],
                        nick['id'],
                        config['server'],
                        nick['name'],
                        '@' if nick['admin'] else '',
                        '{}, https://alik.cz/u/{}'.format(
                            nick['sex'],
                            nick['id'],
                        ),
                    ))
        else:
            nicks = dict()
            for room in rooms:
                for nick in room['users']:
                    if len(args) > 1 and args[1] == 'o' and not nick['admin']:
                        continue
                    nicks[nick['name']] = {
                        'link': nick['id'],
                        'sex': nick['sex'],
                    }
            for nick, data in sorted(nicks.items()):
                if not mask.match(nick) and \
                    not mask.match(data['link']) and \
                    not mask.match(data['sex']):
                    continue
                self.reply('{} {} * {} alik.cz {} {} H :0 {}'.format(
                    IRC.RPL_WHOREPLY.value,
                    self.user,
                    data['link'],
                    config['server'],
                    nick,
                    '{}, https://alik.cz/u/{}'.format(
                        data['sex'],
                        data['link'],
                    ),
                ))
        self.reply('{} {} {} :End of /WHO list.'.format(
            IRC.RPL_ENDOFWHO.value,
            self.user,
            args[0],
        ))

    # TODO: Implement this
    # This should query the profile page info, so blocked by Malicek
    def handle_whois(self, args):
        """Handle WHOIS commands.

        Not implemented.

        :param args: [target] <mask>[,<mask>]*
        """
        logger.debug(args)
        if not args:
            self.error(IRC.ERR_NEEDMOREPARAMS)
            return
        self.error(IRC.ERR_UNKNOWNCOMMAND)

    # TODO: Implement this
    def handle_whowas(self, args):
    # This should query the profile page info, so blocked by Malicek
        """Handle WHOWAS commands.

        Not implemented.

        :param args: <nick>[,<nick>]* [<count> [<target>]]
        """
        logger.debug(args)
        if not args:
            self.error(IRC.ERR_NEEDMOREPARAMS)
            return
        self.error(IRC.ERR_UNKNOWNCOMMAND)

    def handle_kill(self, args):
        pass

    def handle_ping(self, args):
        """Handle PING commands.

        Respond with an appropriate PONG.  Since we are a virtual
        server, we speak for all of them.  In the two argument form,
        the first argument is the origin, such as the user name or
        another server, and the other argument is the target.

        In a single argument form, only the target is given.

        :param args: <server> [<server>]
        """
        logger.debug(args)
        if not args:
            self.error(IRC.ERR_NEEDMOREPARAMS)
            return
        self.reply('PONG {}'.format(
            config['server'],
        ))

    def handle_pong(self, args):
        """Handle PONG commands.

        Responses to PINGs.  We don't send any PINGs but it's okay
        if the client somehow sends these.  Just drop them.

        :param args: <server> [<server>]
        """
        if not args:
            self.error(IRC.ERR_NEEDMOREPARAMS)
            return
        logger.debug(args)

    def handle_error(self, args):
        """Handle ERROR commands.

        The ERROR command is only supposed to be sent by servers, not
        clients.  There are no defined numerics for responses to these.
        We could send ERR_UNKNOWNCOMMAND, but since we're handling it,
        we'll just ignore it.

        :param args: <message>
        """
        if not args:
            self.error(IRC.ERR_NEEDMOREPARAMS)
            return
        logger.debug(args)

    def handle_away(self, args):
        pass

    def handle_rehash(self, args):
        pass

    def handle_die(self, args):
        pass

    def handle_restart(self, args):
        pass

    def handle_summon(self, args):
        pass

    def handle_users(self, args):
        pass

    def handle_wallops(self, args):
        pass

    def handle_userhost(self, args):
        pass

    def handle_ison(self, args):
        pass

def sanitize(nick):
    """Nick substitutions

    Sanitize nicks that are not generally acceptable or break the IRC
    protocol.  Namely this replaces spaces with non-breakable spaces.

    :param nick: The original nickname
    :returns: Modified nickname
    """
    return nick.replace('\x20', '\xa0')

def emoji(msg):
    """Replace Alík's emoticons with corresponding emojis.
    These are not exact match but are close enough.

    :param msg: The original message
    :returns: Message with emoji substitutions
    """
    msg = msg.replace('[:-)]', '🙂')
    msg = msg.replace('[:->]', '😀')
    msg = msg.replace('[:-D]', '😆')
    msg = msg.replace('[;-D]', '🤣')
    msg = msg.replace('[;-)]', '😉')
    msg = msg.replace('[:-|]', '😐')
    msg = msg.replace('[:-P]', '😛')
    msg = msg.replace('[8-D]', '😂')
    msg = msg.replace('[8-o]', '😲')
    msg = msg.replace('[:-o]', '😮')
    msg = msg.replace('[:-(]', '😟')
    msg = msg.replace('[:-E]', '😡')
    msg = msg.replace('[;-(]', '😢')
    msg = msg.replace('[:-c]', '😩')
    msg = msg.replace('[:-Q]', '🤮')
    msg = msg.replace('[8-P]', '😜')
    msg = msg.replace('[:-3]', '😊')
    msg = msg.replace('[:-$]', '🤢')
    msg = msg.replace('[O:-)]', '😇')
    msg = msg.replace('[]:-)]', '😈')
    msg = msg.replace('[Z]', '⚡')
    msg = msg.replace('[?]', '❓')
    msg = msg.replace('[!]', '❗')
    msg = msg.replace('[R^]', '👍')
    msg = msg.replace('[Rv]', '👎')
    msg = msg.replace('[O=]', '💡')
    msg = msg.replace('[@)->-]', '🌹')
    msg = msg.replace('[@=]', '💣')
    msg = msg.replace('[8=]', '💀')
    msg = msg.replace('[$>]', '💗')
    msg = msg.replace('B-)', '😎')
    msg = msg.replace(':-[)', '😷')
    msg = msg.replace('8-[)', '😷')
    msg = msg.replace('(8:O)', '🦛')
    msg = msg.replace('(8:o)', '🦛')
    msg = msg.replace('(8:°)', '🦛')
    msg = msg.replace('(ÍÍÍ)', '🍰')
    return msg

def accept(sock):
    """Accept new connections.

    Accepts all incoming connections, configures them as non-blocking and
    registers them with our master selector.

    Creates a buffer and a Client instance for each connection.

    :param sock: Listening socket with the pending connection request
    """
    conn, addr = sock.accept()
    logger.info('Accepting connection from %s', addr)
    conn.setblocking(False)
    sel.register(
        conn,
        (selectors.EVENT_READ),
        data=types.SimpleNamespace(buf=b'', client=Client(conn))
    )

def handle(key, mask):
    """Handle read evenets from the selector.

    Reads all pending data into a buffer, splitting it by CRLF to generate
    IRC messages.  These are later passed to Client.handle().

    Closes sockets and unregisters them from the selector when appropriate.

    :param key: The selector key object
    :param mask: The selector event mask
    """
    sock = key.fileobj
    data = key.data
    if mask & selectors.EVENT_READ:
        recv = sock.recv(config['buffer'])
        if recv:
            data.buf += recv
        else:
            sel.unregister(sock)
            sock.close()
    while data.buf:
        pos = data.buf.find(b'\r\n')
        if pos != -1:
            cmd = data.buf[0:pos]
            data.buf = data.buf[pos + 2:]
            data.client.handle(cmd)
            continue
        break

def load_config(configFile):
    """Load mlck configuration file.

    Attempts to read the supplied config file and populates the
    global config, conf.

    :param configFile: Path to the configuration file
    """
    global config
    defaults = {
        'server': 'mlck',
        'loglevel': 'INFO',
        'listen': '127.0.0.1',
        'port': 6667,
        'buffer': 1024,
        'encoding': 'utf-8',
        'endpoint': 'http://localhost:3000',
        'refresh': 5,
        'timeout': 2.5,
        'color': '#000000',
    }
    cnf = configparser.ConfigParser()
    if not os.path.isfile(configFile):
        logger.critical('Configuration file "%s" not found.', configFile)
        sys.exit(1)
    try:
        cnf.read(configFile)
    except:
        logger.critical('Failed to parse the configuration file.')
        sys.exit(1)
    if not cnf.has_section('mlck'):
        logger.critical('Configuration is missing the mlck section.')
        sys.exit(1)
    try:
        # Strings
        for opt in ('server', 'loglevel', 'listen', 'encoding', \
            'endpoint', 'color'):
            config[opt] = cnf.get('mlck', opt, fallback=defaults[opt])
        # Ints
        for opt in ('port', 'buffer'):
            config[opt] = cnf.getint('mlck', opt, fallback=defaults[opt])
        # Floats
        for opt in ('refresh', 'timeout'):
            config[opt] = cnf.getfloat('mlck', opt, fallback=defaults[opt])
    except ValueError:
        logger.critical('Failed parsing the configuration file.')
        sys.exit(1)
    loglevel = getattr(logging, config['loglevel'].upper())
    if not isinstance(loglevel, int):
        logger.critical('Invalid log level configured.')
        sys.exit(1)
    logger.setLevel(loglevel)
    if config['endpoint'].endswith('/'):
        config['endpoint'] = config['endpoint'][:-1]

def main():
    """The main body of the application.

    Sets everything up and begins listening for connections.

    Relies on selectors for input.
    """
    defaultconfig = os.path.join(os.sep, 'etc', 'mlck.conf')
    ap = argparse.ArgumentParser()
    ap.add_argument(
        '-c', '--config',
        dest='config',
        default=defaultconfig,
        help='mlck configuration file, defaults to {}'.format(defaultconfig),
    )
    ap.add_argument(
        '-q', '--quiet',
        dest='quiet',
        action='store_true',
        default=False,
        help='disable all output, regardless of loglevel configuration',
    )
    args = ap.parse_args()
    load_config(args.config)
    if args.quiet:
        logging.disable(logging.CRITICAL)
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock6 = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock6.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind((config['listen'], config['port']))
    sock.listen()
    sock.setblocking(False)
    sel.register(sock, selectors.EVENT_READ, data=None)
    logger.info('%s, %s starting...', config['server'], AGENT)
    logger.info('Listening for connections on %s port %s.',
        config['listen'], config['port'])
    while True:
        events = sel.select(timeout=None)
        for k, m in events:
            if k.data is None:
                accept(k.fileobj)
            else:
                handle(k, m)

if __name__ == '__main__':
    main()
